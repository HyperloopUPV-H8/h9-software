package vehicle

import (
	"errors"
	"strings"

	"github.com/HyperloopUPV-H8/h9-backend/internal/update_factory"
	"github.com/HyperloopUPV-H8/h9-backend/pkg/abstraction"
	connection_topic "github.com/HyperloopUPV-H8/h9-backend/pkg/broker/topics/connection"
	data_topic "github.com/HyperloopUPV-H8/h9-backend/pkg/broker/topics/data"
	logger_topic "github.com/HyperloopUPV-H8/h9-backend/pkg/broker/topics/logger"
	message_topic "github.com/HyperloopUPV-H8/h9-backend/pkg/broker/topics/message"
	order_topic "github.com/HyperloopUPV-H8/h9-backend/pkg/broker/topics/order"
	"github.com/HyperloopUPV-H8/h9-backend/pkg/logger"
	data_logger "github.com/HyperloopUPV-H8/h9-backend/pkg/logger/data"
	order_logger "github.com/HyperloopUPV-H8/h9-backend/pkg/logger/order"
	protection_logger "github.com/HyperloopUPV-H8/h9-backend/pkg/logger/protection"
	state_logger "github.com/HyperloopUPV-H8/h9-backend/pkg/logger/state"
	"github.com/HyperloopUPV-H8/h9-backend/pkg/transport"
	blcu_packet "github.com/HyperloopUPV-H8/h9-backend/pkg/transport/packet/blcu"
	"github.com/HyperloopUPV-H8/h9-backend/pkg/transport/packet/data"
	"github.com/HyperloopUPV-H8/h9-backend/pkg/transport/packet/order"
	"github.com/HyperloopUPV-H8/h9-backend/pkg/transport/packet/protection"
	"github.com/HyperloopUPV-H8/h9-backend/pkg/transport/packet/state"
	"github.com/rs/zerolog"
)

// Vehicle is the main abstraction that coordinates the backend modules.
// It receives its modules and once it is ready, the vehicle manages the flow of
// information between them, converting events generated by one module to the specific
// input for another one.
type Vehicle struct {
	broker        abstraction.Broker
	boards        map[abstraction.BoardId]abstraction.Board
	transport     abstraction.Transport
	logger        abstraction.Logger
	updateFactory *update_factory.UpdateFactory
	idToBoardName map[uint16]string
	ipToBoardId   map[string]abstraction.BoardId

	trace zerolog.Logger
}

// Notification is the method invoked by transport to notify of a new event (e.g.packet received)
func (vehicle *Vehicle) Notification(notification abstraction.TransportNotification) {
	vehicle.trace.Trace().Type("notification", notification).Msg("notification")

	packet, ok := notification.(transport.PacketNotification)
	if !ok {
		vehicle.trace.Warn().Type("notification", notification).Msg("unexpected notification type")
		return
	}

	switch p := packet.Packet.(type) {
	case *data.Packet:
		update := vehicle.updateFactory.NewUpdate(p)
		err := vehicle.broker.Push(data_topic.NewPush(&update))
		if err != nil {
			vehicle.trace.Error().Stack().Err(err).Msg("broker push")
		}

		err = vehicle.logger.PushRecord(&data_logger.Record{
			Packet:    p,
			From:      packet.From,
			To:        packet.To,
			Timestamp: packet.Timestamp,
		})

		if err != nil && !errors.Is(err, logger.ErrLoggerNotRunning{}) {
			vehicle.trace.Error().Stack().Err(err).Msg("logger push")
		}

	case *protection.Packet:
		boardId := vehicle.ipToBoardId[strings.Split(packet.From, ":")[0]]
		err := vehicle.broker.Push(message_topic.Push(p, boardId))
		if err != nil {
			vehicle.trace.Error().Stack().Err(err).Msg("broker push")
		}

		err = vehicle.logger.PushRecord(&protection_logger.Record{
			Packet:    p,
			BoardId:   boardId,
			From:      packet.From,
			To:        packet.To,
			Timestamp: packet.Timestamp,
		})

		if err != nil && !errors.Is(err, logger.ErrLoggerNotRunning{}) {
			vehicle.trace.Error().Stack().Err(err).Msg("logger push")
		}

	case *blcu_packet.Ack:
		vehicle.trace.Warn().Msg("blcu ack not implemented")
	case *state.Space:
		err := vehicle.logger.PushRecord(&state_logger.Record{
			Packet:    p,
			From:      packet.From,
			To:        packet.To,
			Timestamp: packet.Timestamp,
		})

		if err != nil && !errors.Is(err, logger.ErrLoggerNotRunning{}) {
			vehicle.trace.Error().Stack().Err(err).Msg("logger push")
		}

	case *order.Add:
		vehicle.trace.Warn().Msg("state order add not implemented")
	case *order.Remove:
		vehicle.trace.Warn().Msg("state order remove not implemented")
	default:
		vehicle.trace.Warn().Type("packet", packet.Packet).Msg("unrecognized packet")
	}
}

// UserPush is the method invoked by boards to signal the user has sent information to the back
func (vehicle *Vehicle) UserPush(push abstraction.BrokerPush) {
	vehicle.trace.Trace().Type("push", push).Msg("user push")

	switch push := push.(type) {
	case *order_topic.Order:
		packet, err := push.ToPacket()
		if err != nil {
			vehicle.trace.Error().Stack().Err(err).Type("topic", push).Msg("convert to packet")
			return
		}

		err = vehicle.transport.SendMessage(transport.NewPacketMessage(packet))
		if err != nil {
			vehicle.trace.Error().Stack().Err(err).Type("topic", push).Msg("sending")
			return
		}

		err = vehicle.logger.PushRecord(&order_logger.Record{
			Packet:    packet,
			From:      "backend",
			To:        vehicle.idToBoardName[uint16(packet.Id())],
			Timestamp: packet.Timestamp(),
		})

		if err != nil && !errors.Is(err, logger.ErrLoggerNotRunning{}) {
			vehicle.trace.Error().Stack().Err(err).Msg("logger push")
		}
	case *logger_topic.Status:
		var err error
		if push.Enable() {
			err = vehicle.logger.Start()
		} else {
			err = vehicle.logger.Stop()
		}

		if err != nil {
			push.Fulfill(!push.Enable())
		} else {
			push.Fulfill(push.Enable())
		}
	default:
		vehicle.trace.Warn().Type("push", push).Msg("unrecognized push")
	}
}

// Request is the method invoked by a board to ask for a resource from the frontend
func (vehicle *Vehicle) Request(abstraction.BrokerRequest) (abstraction.BrokerResponse, error) {
	panic("TODO")
}

// SendMessage is the method invoked by a board to send a message
func (vehicle *Vehicle) SendMessage(abstraction.TransportMessage) error {
	panic("TODO")
}

// SendPush is the method invoked by a board to send a message to the frontend
func (vehicle *Vehicle) SendPush(abstraction.BrokerPush) error {
	panic("TODO")
}

// ConnectionUpdate is the method invoked by transport to signal a connection state has changed
func (vehicle *Vehicle) ConnectionUpdate(target abstraction.TransportTarget, isConnected bool) {
	vehicle.trace.Info().Str("target", string(target)).Bool("isConnected", isConnected).Msg("connection update")
	vehicle.broker.Push(connection_topic.NewConnection(string(target), isConnected))
	if isConnected {
		vehicle.updateFactory.ClearPacketsFor(target)
	}
}
